\documentclass[journal]{IEEEtran}
\usepackage{blindtext}
\usepackage{graphicx}
\usepackage[none]{hyphenat}
\usepackage{minted}
\usepackage[dvipsnames]{xcolor}

\definecolor{LightGray}{HTML}{F9F9F9}

\setminted{breaklines=true}
\usemintedstyle{monokailight}

\begin{document}
\title{Android Performance Analysis and \\ Optimization Techniques}

\author{Areeb Jamal and Divya Prakash Varshney \\
	 \IEEEmembership{Computer Engineering 3rd Year, ZHCET}}

% The paper headers
\markboth{Android Optimization Techniques, April~2016}%
{Android Performance}


% make the title area
\maketitle


\begin{abstract}
Android, being the most widely used operating system in the world, has attracted a large number of developers throughout the world. And since, the official programming language used to develop Android Apps is Java, the developers coming from its background often make wrong assumptions about the best practices in Android. Making these apps perform poorly in respect to CPU and memory utilisation. The purpose of this paper is to discuss some common solutions to optimization problems associated with Android.
\end{abstract}


\section{Introduction}
There are 3 areas of performance in mobile computing :
\begin{itemize}
	\item CPU
	\item Memory
	\item Network
\end{itemize}
Because of the fact that \emph{Network} optimization is generally language agnostic and is covered in various modern netwroking libraries, we will focus on \emph{CPU} and \emph{Memory} usage optimization and analysis techniques.\\
The CPU utilization in case of mobile computing can be closely tied to memory as poor RAM optimisation may lead to repeated calls of Garbage Collector leading to wasteful CPU cycles meaning frame rate drops, so in order to optimize CPU performance, we should also improve the memory usage of the application.

\section{Need of Performance}
The need to optimize performance of any application comes from a basic need of user to avoid using applications that lag through the common workflow.\\
To ensure smooth performance, app needs to call the basic \emph{onDraw()} function 60 times a second, leading to the 60 FPS mark of GPU rendering. Any operation that reduces the number of calls of this function leads to detrimental performance. The reason of this frame rate drop can be anything that keeps CPU busy and thus unable to call \emph{onDraw()} enough times.\\
Also, Android emplys a \emph{Low Memory Killer (LMK)} which kills backround applications according to memory they are using, meaning the better memory optimization we use, more time our app gets to live in background.\\
We will now enumerate the reasons why an Android application lags

\newpage

\subsection{Heavy Computations or Network Calls}
Heavy Computations or Network Calls \emph{(like downloading images, making API calls, etc)} when done on Main Thread \emph{(known as UI thread in Android)}, lead to wasteful CPU cycles which could be used to render UI. These computations can emulate \emph{blocking} or \emph{busy waiting} and thus should be moved to another \emph{Thread} of their own.\\
A further improvement can be made by caching the frequently made calculations, removing the need of using threads. Caching does not necessarily improve performance but decreases the waiting time for the user as concurrency ensures no frame rate drops but still takes the same amount of time in calculating the results.\\
Since it is a well known solution \emph{(yet developers tend to ignore)}, we will not discuss it any further.

\subsection{Repeated GC Calls}
Another reason developers forget to consider is that the Android runtime invokes Garbage Collector every time it needs to replenish the memory as it feels the free RAM is getting less. If there are huge memory allocations in the application, GC call frequency will be considerably increased and thus frame rates will drop leading to lag.\\
Common solution to this problem is using better data structures specific to Android, usually not consistent with the Java Development Guidlines, as it focuses on general development.

\subsection{Memory Leaks}
A severe case of repeated GC calls take place if there is a memory leak. Because GC cannot reclaim memory on each run, Android Runtime continues invoking it until a minimum amount of free RAM is ensured. With a memory leak, this won't be able to happen and thus, GC will run more frequently, increasing the memory consumed by our and and also decreasing its performance.

\newpage

\section{Analysis and Solutions}
In further sections, we will discuss the topics we analysed and provide solutions to those specific problems in context of Android Development

\subsection{Memory Leaks}
Major portion of our analysis has been on memory leaks and to provide better solutions to ensure they don't happen. We will start by defining a memory leak.\\

\subsubsection{Definition}
A memory leak is a type of resource leak that occurs when a computer program incorrectly manages memory allocations in such a way that memory which is no longer needed is not released. In object-oriented programming, a memory leak may happen when an object is stored in memory but cannot be accessed by the running code.

Because they can exhaust available system memory as an application runs, memory leaks are often the cause of or a contributing factor to software aging.\\

\subsubsection{Common memory leaks}

\subsection{ArrayList Optimizations}
ArrayList is most commonly used List, used to store arrays data of same type. ArrayList in java have some default size but Android SDk initialize ArrayList with size 0 by default.When any data is added to ArrayList, it first checks if the size of ArrayList is sufficient enough to save the data if yes then it easily stores data but in case where the ArrayList's size isn't enough to accomodate the data, ArrayList allocated a new memory with larger size (in multiples of 8) and copy all the previously stored data in new memory and then remove old memory used and finally add the new data.\\
For example : If there are 1000 objects to be stored in ArrayList and objects are added one by one then suppose if the ArrayList doesn't have memory to store 1000th object then a new memory location will be allocated, all data from previous memory will be copied and then the new data (1000th object) will be added. \\ 
The allocation of memory again and again, and copying the data from previous location to new taked enough amout of time also if the object's size is huge then copying the single object may take a lot time.\\\\
A better approach would be intializing arraylist with the data size for example :\\

\begin{minted}[bgcolor=LightGray]{Java}
public List<String> getStudents(List<Student> students){
  List<String> student = new ArrayList<>(students.size());
  for (Student s : students){
    student.add(s.name);
  }
  return student;
}
\end{minted}
This will allocate the memory only once and lot of time will be saved in allocating and copying
the data.

\section{Conclusion}
\blindtext

\begin{minted}[bgcolor=LightGray]{Java}
public static void main(String... args) {
    System.out.println();
}
\end{minted}


\appendices
\section{Proof of the First Zonklar Equation}
Some text for the appendix.

% use section* for acknowledgement
\section*{Acknowledgment}

The authors would like to thank...

\begin{thebibliography}{1}

\bibitem{}
H.~Kopka and P.~W. Daly, \emph{A Guide to \LaTeX}, 3rd~ed. Harlow, England: Addison-Wesley, 1999.

\end{thebibliography}

\begin{IEEEbiography}[{\includegraphics[width=1in,height=1.25in,clip,keepaspectratio]{picture}}]{John Doe}
\blindtext
\end{IEEEbiography}

\end{document}


