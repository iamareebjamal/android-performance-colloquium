\documentclass[journal]{IEEEtran}
\usepackage{blindtext}
\usepackage{graphicx}
\usepackage[none]{hyphenat}
\usepackage{minted}
\usepackage[dvipsnames]{xcolor}

\definecolor{LightGray}{HTML}{F9F9F9}

\setminted{breaklines=true}
\usemintedstyle{monokailight}

\begin{document}
\title{Android Performance Analysis and \\ Optimization Techniques}

\author{Areeb Jamal and Divya Prakash Varshney \\
	 \IEEEmembership{Computer Engineering 3rd Year, ZHCET}}

% The paper headers
\markboth{Android Optimization Techniques, April~2016}%
{Android Performance}


% make the title area
\maketitle


\begin{abstract}
Android, being the most widely used operating system in the world, has attracted a large number of developers throughout the world. And since, the official programming language used to develop Android Apps is Java, the developers coming from its background often make wrong assumptions about the best practices in Android. Making these apps perform poorly in respect to CPU and memory utilisation. The purpose of this paper is to discuss some common solutions to optimization problems associated with Android.
\end{abstract}


\section{Introduction}
There are 3 areas of performance in mobile computing :
\begin{itemize}
	\item CPU
	\item Memory
	\item Network
\end{itemize}
Because of the fact that \emph{Network} optimization is generally language agnostic and is covered in various modern netwroking libraries, we will focus on \emph{CPU} and \emph{Memory} usage optimization and analysis techniques.\\
The CPU utilization in case of mobile computing can be closely tied to memory as poor RAM optimisation may lead to repeated calls of Garbage Collector leading to wasteful CPU cycles meaning frame rate drops, so in order to optimize CPU performance, we should also improve the memory usage of the application.

\section{Need of Performance}
The need to optimize performance of any application comes from a basic need of user to avoid using applications that lag through the common workflow.\\
To ensure smooth performance, app needs to call the basic \emph{onDraw()} function 60 times a second, leading to the 60 FPS mark of GPU rendering. Any operation that reduces the number of calls of this function leads to detrimental performance. The reason of this frame rate drop can be anything that keeps CPU busy and thus unable to call \emph{onDraw()} enough times.\\
Also, Android emplys a \emph{Low Memory Killer (LMK)} which kills backround applications according to memory they are using, meaning the better memory optimization we use, more time our app gets to live in background.\\
We will now enumerate the reasons why an Android application lags

\newpage

\subsection{Heavy Computations or Network Calls}
Heavy Computations or Network Calls \emph{(like downloading images, making API calls, etc)} when done on Main Thread \emph{(known as UI thread in Android)}, lead to wasteful CPU cycles which could be used to render UI. These computations can emulate \emph{blocking} or \emph{busy waiting} and thus should be moved to another \emph{Thread} of their own.\\
A further improvement can be made by caching the frequently made calculations, removing the need of using threads. Caching does not necessarily improve performance but decreases the waiting time for the user as concurrency ensures no frame rate drops but still takes the same amount of time in calculating the results.\\
Since it is a well known solution \emph{(yet developers tend to ignore)}, we will not discuss it any further.

\subsection{Repeated GC Calls}
Another reason developers forget to consider is that the Android runtime invokes Garbage Collector every time it needs to replenish the memory as it feels the free RAM is getting less. If there are huge memory allocations in the application, GC call frequency will be considerably increased and thus frame rates will drop leading to lag.\\
Common solution to this problem is using better data structures specific to Android, usually not consistent with the Java Development Guidlines, as it focuses on general development.

\subsection{Memory Leaks}
A severe case of repeated GC calls take place if there is a memory leak. Because GC cannot reclaim memory on each run, Android Runtime continues invoking it until a minimum amount of free RAM is ensured. With a memory leak, this won't be able to happen and thus, GC will run more frequently, increasing the memory consumed by our and and also decreasing its performance.

\newpage

\section{Analysis and Solutions}
In further sections, we will discuss the topics we analysed and provide solutions to those specific problems in context of Android Development

\subsection{Memory Leaks}
Major portion of our analysis has been on memory leaks and to provide better solutions to ensure they don't happen. We will start by defining a memory leak.\\

\subsubsection{Definition}
A memory leak [6] is a type of resource leak that occurs when a computer program incorrectly manages memory allocations in such a way that memory which is no longer needed is not released. In object-oriented programming, a memory leak may happen when an object is stored in memory but cannot be accessed by the running code.

Because they can exhaust available system memory as an application runs, memory leaks are often the cause of or a contributing factor to software aging.\\

\subsubsection{Common memory leaks}

\subsection{ArrayList Optimizations}
ArrayList is most commonly used List, used to store arrays data of same type. ArrayList in java have some default size but Android SDk initialize ArrayList with size 0 by default.When any data is added to ArrayList, it first checks if the size of ArrayList is sufficient enough to save the data if yes then it easily stores data but in case where the ArrayList's size isn't enough to accomodate the data, ArrayList allocated a new memory with larger size (in multiples of 8) and copy all the previously stored data in new memory and then remove old memory used and finally add the new data.

\emph{For example :} If there are 1000 objects to be stored in ArrayList and objects are added one by one then suppose if the ArrayList doesn't have memory to store 1000th object then a new memory location will be allocated, all data from previous memory will be copied and then the new data (1000th object) will be added.

The allocation of memory again and again, and copying the data from previous location to new taked enough amout of time also if the object's size is huge then copying the single object may take a lot time.

A better approach would be intializing arraylist with the data size for example :

\begin{minted}[bgcolor=LightGray]{Java}
public List<String> getStudents(List<Student> students){
  List<String> student = new ArrayList<>(students.size());
  for (Student s : students){
    student.add(s.name);
  }
  return student;
}
\end{minted}
This will allocate the memory only once and lot of time will be saved in allocating and copying
the data.


\subsection{Enums vs Static Constants}
Whenever we need to define states of the object we use Enums. Enums are like classes which have their own variable and can also have their own methods.Since they act like classes there is an associated memory overheads.Although Enums can help in securing type safety but in case of android it must be avoided. The drawback of Enums as memory overhead is much more that advantage of typesafe as memory is the crucial element in android.

\emph{For example :} If a simplest enum is instansiated it has 500 bytes of memory overhead by default and if somehow we forget to make them static then every object would have it's own reference of enums and can cause lot of memory wastage.

A better approach to this problem is using static final constants which will require lot less memory than Enums and fulfill alomost same work as Enums.

\begin{itemize}
	\item Enums
\begin{minted}[bgcolor=LightGray]{Java}
public static enum State {
  int ON =  1;
  int OFF = 0;
};
\end{minted}
	\item Static Constants
\begin{minted}[bgcolor=LightGray]{Java}
static final int ON =  1;
static final int OFF = 0;
\end{minted}
\end{itemize}

\subsection{StringBuilder Optimizations}
As we talked about ArrayList, StringBuilder also does the same thing but in the case of StringBuilder the stituation is even worse. This is because StringBuilder assigns the memory exactly to the size of string needed to append + 1 to store end of string. The stituation become worse and worse everytime a new string is appended because everytime the string appends in StringBuilder , each time a new Memory is allocated with size of previous allocated memory + new String Size +1. Consider an example where you need to 1000 names in a single string, using StringBuilder it would take 1000 allocation of memory and every time it allocate the memory the previous memory is copied into new one making StringBuiler much worse than ArrayList.
\begin{minted}[bgcolor=LightGray]{Java}
public String getNames(List<Student> students){
  StringBuilder sb = new StringBuilder();
  for (Student s : students){
    sb.append(s.name + " ");
  }
  return sb.toString();
}
\end{minted}
A simple Solution to this problem is using the some random number (for say 20) and then intialize the StringBuilder with averageNumber * number of strings to append. This will allow to allocate the StringBuilder a starting memory and can help in reducing the allocations and memory.
\begin{minted}[bgcolor=LightGray]{Java}
public getNames(List<Student> students){
  int num = 20;
  StringBuilder sb = new StringBuilder(num*student.size());
  for (Student s : students){
    sb.append(s.name + " ");
  }
  return sb.toString();
}
\end{minted}

\section{Conclusion}
\blindtext

\begin{minted}[bgcolor=LightGray]{Java}
public static void main(String... args) {
    System.out.println();
}
\end{minted}

\section*{Acknowledgment}

The authors would like to thank Jake Wharton on his Presentation on \emph{Hidden Java Costs}

\begin{thebibliography}{1}

\bibitem{}
Yoonsik Cheon, \emph{Are Java Programming Best Practices Also Best Practices for Android?}, The University of Texas at El Paso, USA

\bibitem{}
Prajakta Gotarane and Sumedh Pundkar, \emph{Smart Coding using New Code Optimization Techniques in Java to Reduce Runtime Overhead of Java Compiler}, UMIT, SNDT Womens University, Santacruz, Mumbai

\bibitem{}
J. Bloch, Effective Java, second edition, Addison-Wesley, 2008.

\bibitem{}
Jake Wharton, \emph{Hidden Java Costs}

\bibitem{}
Best Practice for Performance,\\
https://developer.android.com/training/best-performance.html 

\bibitem{}
Memory Leak,\\
https://en.wikipedia.org/wiki/Memory-leak

\end{thebibliography}

\end{document}


